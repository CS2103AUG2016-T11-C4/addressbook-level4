# A0140145W

###### src\main\java\seedu\address\commons\core\IndexPrefix.java

``` java
/**
 * Index prefixes for different kinds of tasks.
 */
public enum IndexPrefix {

    FLOAT("f", "floating task index"),
    DEADLINE("d", "deadline task index"),
    EVENT("e", "event task index");

    private final String prefixString;
    private final String name;

    IndexPrefix(String prefixString, String name) {
        this.prefixString = prefixString;
        this.name = name;
    }

    public String getPrefixString() {
        return prefixString;
    }

    public String getName() {
        return name;
    }

}
```
###### src\main\java\seedu\address\commons\core\Version.java

``` java
    @Override
    public int compareTo(Version other) {
        return this.major != other.major ? this.major - other.major
               : this.minor != other.minor ? this.minor - other.minor
               : this.patch != other.patch ? this.patch - other.patch
               : this.isEarlyAccess == other.isEarlyAccess() ? 0
               : this.isEarlyAccess ? -1 : 1;
    }

```
###### src\main\java\seedu\address\commons\events\model\TaskBookChangedEvent.java

``` java
    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
                .add("floatingTasks", data.getFloatingTasks().size())
                .add("deadlineTasks", data.getDeadlineTasks().size())
                .add("eventTasks", data.getEventTasks().size())
                .toString();
    }
}
```
###### src\main\java\seedu\address\commons\exceptions\IllegalValueException.java

``` java
    /**
     * @param message should contain relevant information on the failed constraint(s).
     * @param cause The Throwable which caused this exception to be thrown.
     */
    public IllegalValueException(String message, Throwable cause) {
        super(message, cause);
    }
}
```
###### src\main\java\seedu\address\commons\time\LocalDateTimeDuration.java

``` java
/**
 * Represents a period bounded by two LocalDateTimes.
 *
 * Guarantees: Immutable POJO with non-null values. End LocalDateTime is after start LocalDateTime.
 */
public final class LocalDateTimeDuration implements Comparable<LocalDateTimeDuration>, TemporalAmount {

    private static final String FMT_STRING = "LocalDateTimeDuration[start=%s, end=%s]";

    private final LocalDateTime start;

    private final LocalDateTime end;

    private final Duration duration;

    public LocalDateTimeDuration(LocalDateTime start, LocalDateTime end) throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(start, end);
        if (end.isBefore(start)) {
            throw new IllegalValueException("end datetime must be after start datetime");
        }
        this.start = start;
        this.end = end;
        this.duration = Duration.between(start, end);
    }

    public LocalDateTime getStart() {
        return start;
    }

    public LocalDateTime getEnd() {
        return end;
    }

    @Override
    public Temporal addTo(Temporal temporal) {
        return temporal.plus(duration);
    }

    @Override
    public long get(TemporalUnit unit) {
        return duration.get(unit);
    }

    @Override
    public List<TemporalUnit> getUnits() {
        return duration.getUnits();
    }

    @Override
    public Temporal subtractFrom(Temporal temporal) {
        return temporal.minus(duration);
    }

    @Override
    public int compareTo(LocalDateTimeDuration other) {
        int cmp = start.compareTo(other.start);
        if (cmp != 0) {
            return cmp;
        }
        return start.compareTo(other.end);
    }

    @Override
    public boolean equals(Object other) {
        return other == this
               || (other instanceof LocalDateTimeDuration
               && start.equals(((LocalDateTimeDuration)other).start)
               && end.equals(((LocalDateTimeDuration)other).end));
    }

    @Override
    public int hashCode() {
        return Objects.hash(start, end);
    }

    @Override
    public String toString() {
        return String.format(FMT_STRING, start, end);
    }

}
```
###### src\main\java\seedu\address\commons\util\MappedList.java

``` java
public class MappedList<E, F> extends TransformationList<E, F> {

    private final Function<F, E> mapper;

    public MappedList(ObservableList<? extends F> source, Function<F, E> mapper) {
        super(source);
        this.mapper = mapper;
    }

    @Override
    public int getSourceIndex(int index) {
        return index;
    }

    @Override
    public E get(int index) {
        return mapper.apply(getSource().get(index));
    }

    @Override
    public int size() {
        return getSource().size();
    }

    @Override
    protected void sourceChanged(Change<? extends F> c) {
        fireChange(new Change<E>(this) {

            @Override
            public boolean wasAdded() {
                return c.wasAdded();
            }

            @Override
            public boolean wasRemoved() {
                return c.wasRemoved();
            }

            @Override
            public boolean wasReplaced() {
                return c.wasReplaced();
            }

            @Override
            public boolean wasUpdated() {
                return c.wasUpdated();
            }

            @Override
            public boolean wasPermutated() {
                return c.wasPermutated();
            }

            @Override
            public int getPermutation(int i) {
                return c.getPermutation(i);
            }

            @Override
            protected int[] getPermutation() {
                // This method is only called by the superclass methods
                // wasPermutated() and getPermutation(int), which are
                // both overriden by this class. There is no other way
                // this method can be called.
                throw new AssertionError("Unreachable code");
            }

            @Override
            public List<E> getRemoved() {
                ArrayList<E> res = new ArrayList<>(c.getRemovedSize());
                for (F e: c.getRemoved()) {
                    res.add(mapper.apply(e));
                }
                return res;
            }

            @Override
            public int getFrom() {
                return c.getFrom();
            }

            @Override
            public int getTo() {
                return c.getTo();
            }

            @Override
            public boolean next() {
                return c.next();
            }

            @Override
            public void reset() {
                c.reset();
            }
        });
    }
}
```
###### src\main\java\seedu\address\commons\util\ObservableListChangeListener.java

``` java
/**
 * A utility class that tracks whether ObservableList(s) have changed.
 */
public class ObservableListChangeListener {

    private boolean hasChanged = false;

    private final ObservableList<?>[] lists;

    public ObservableListChangeListener(ObservableList<?>... lists) {
        // Store a reference to the observable lists so they do not get GC'd
        this.lists = lists;
        // Install our listeners on the observable lists
        for (ObservableList<?> list : lists) {
            list.addListener((ListChangeListener.Change<? extends Object> change) -> {
                hasChanged = true;
            });
        }
    }

    public void setHasChanged(boolean hasChanged) {
        this.hasChanged = hasChanged;
    }

    public boolean getHasChanged() {
        return hasChanged;
    }

}
```
###### src\main\java\seedu\address\commons\util\SubstringRange.java

``` java
/**
 * Represents a subtring of a string.
 */
public class SubstringRange implements Comparable<SubstringRange> {

    private final int start;

    private final int end;

    public SubstringRange(int start, int end) {
        assert start >= 0;
        assert end >= 0;
        assert end >= start;
        this.start = start;
        this.end = end;
    }

    /**
     * Returns a substring range that covers the whole string.
     */
    public static SubstringRange of(String str) {
        return new SubstringRange(0, str.length());
    }

    public int getStart() {
        return start;
    }

    public int getEnd() {
        return end;
    }

    public SubstringRange indent(int x) {
        assert start + x >= 0;
        return new SubstringRange(start + x, end + x);
    }

    @Override
    public int compareTo(SubstringRange other) {
        return ComparisonChain.start()
                .compare(start, other.start)
                .compare(end, other.end)
                .result();
    }

    @Override
    public boolean equals(Object other) {
        return other == this
                || (other instanceof SubstringRange
                && start == ((SubstringRange)other).start
                && end == ((SubstringRange)other).end
                );
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
                .add("start", start)
                .add("end", end)
                .toString();
    }

}
```
###### src\main\java\seedu\address\logic\commands\AddDeadlineCommand.java

``` java
/**
 * Adds an deadline task to the task book.
 */
public class AddDeadlineCommand extends AddTaskCommand {

    public static final String MESSAGE_USAGE = "Parameters for adding deadline: \"NAME\" <DATE> <TIME> \n"
            + "Example: " + COMMAND_WORD + " \"Deadline Name\" 12/12/2016 2pm \n";

    private final DeadlineTask deadlineTask;

    public AddDeadlineCommand(DeadlineTask deadlineTask) {
        this.deadlineTask = deadlineTask;
    }

```
###### src\main\java\seedu\address\logic\commands\AddEventCommand.java

``` java
/**
 * Adds an event task to the task book.
 */
public class AddEventCommand extends AddTaskCommand {

    public static final String MESSAGE_USAGE = "Parameters for adding event: \"NAME\" <STARTING_DATE> <STARTING_TIME> to <ENDING_DATE> <ENDING_TIME>\n"
            + "Example: " + COMMAND_WORD + " \"Event Name\" 12/12/2016 12pm to 2pm \n";

    private final EventTask eventTask;

    public AddEventCommand(EventTask eventTask) {
        this.eventTask = eventTask;
    }

    public AddEventCommand(String name, LocalDateTime start, LocalDateTime end) throws IllegalValueException {
        this(new EventTask(name, start, end));
    }

```
###### src\main\java\seedu\address\logic\commands\AddEventCommand.java

``` java
    @Override
    public CommandResult execute() {
        assert model != null;
        model.addEventTask(eventTask);
        return new CommandResult(String.format(MESSAGE_SUCCESS, eventTask));
    }

}
```
###### src\main\java\seedu\address\logic\commands\AddFloatingTaskCommand.java

``` java
/**
 * Adds an event task to the task book.
 */
public class AddFloatingTaskCommand extends AddTaskCommand {

    public static final String MESSAGE_USAGE = "Parameters for adding floating task: \"NAME\" [p-Priority] \n"
            + "Example: " + COMMAND_WORD + " \"Floating Task Name\" p-3 \n";

    private final FloatingTask floatingTask;

    public AddFloatingTaskCommand(FloatingTask floatingTask) {
        this.floatingTask = floatingTask;
    }

```
###### src\main\java\seedu\address\logic\commands\DeleteEventCommand.java

``` java
public class DeleteEventCommand extends Command {

    public static final String COMMAND_WORD = "del-event";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the event identified by the index number used in the filtered event listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted event: %1$s";

    public final int targetIndex;

    public DeleteEventCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        try {
            final EventTask deletedTask = model.removeEventTask(targetIndex);
            return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, deletedTask));
        } catch (IllegalValueException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

}
```
###### src\main\java\seedu\address\logic\commands\EditEventCommand.java

``` java
public class EditEventCommand extends Command {

    public static final String COMMAND_WORD = "edit-event";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the event identified by the index number used in the filtered event listing.\n"
            + "Parameters: INDEX [sd-NEW_START_TIME | st-NEW_START_DATE | ed-NEW_END_DATE | et-NEW_END_TIME | n-NEW_NAME]"
            + "Example: " + COMMAND_WORD + " 1 st-4pm et-8pm";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Event edited: %1$s";

    public final int targetIndex;
    public final Optional<Name> newName;
    public final Optional<LocalDate> newStartDate;
    public final Optional<LocalTime> newStartTime;
    public final Optional<LocalDate> newEndDate;
    public final Optional<LocalTime> newEndTime;

    public EditEventCommand(int targetIndex, Optional<Name> newName, Optional<LocalDate> newStartDate,
                            Optional<LocalTime> newStartTime, Optional<LocalDate> newEndDate,
                            Optional<LocalTime> newEndTime) {
        this.targetIndex = targetIndex;
        this.newName = newName;
        this.newStartDate = newStartDate;
        this.newStartTime = newStartTime;
        this.newEndDate = newEndDate;
        this.newEndTime = newEndTime;
    }

    public int getTargetIndex() {
        return targetIndex;
    }

    public Optional<LocalDate> getNewStartDate() {
        return newStartDate;
    }

    public Optional<LocalTime> getNewStartTime() {
        return newStartTime;
    }

    public Optional<LocalDate> getNewEndDate() {
        return newEndDate;
    }

    public Optional<LocalTime> getNewEndTime() {
        return newEndTime;
    }

    @Override
    public CommandResult execute() {
        EventTask oldEventTask;
        try {
            oldEventTask = model.getEventTask(targetIndex);
        } catch (IllegalValueException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        EventTask newEventTask;
        try {
            newEventTask = new EventTask(
                    newName.orElse(oldEventTask.getName()),
                    LocalDateTime.of(
                            newStartDate.orElse(oldEventTask.getStart().toLocalDate()),
                            newStartTime.orElse(oldEventTask.getStart().toLocalTime())
                    ),
                    LocalDateTime.of(
                            newEndDate.orElse(oldEventTask.getEnd().toLocalDate()),
                            newEndTime.orElse(oldEventTask.getEnd().toLocalTime())
                    )
            );
        } catch (IllegalValueException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(e.getMessage());
        }

        try {
            model.setEventTask(targetIndex, newEventTask);
        } catch (IllegalValueException e) {
            throw new AssertionError("The target event cannot be missing", e);
        }

        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, newEventTask));
    }

}
```
###### src\main\java\seedu\address\logic\commands\EditFloatingTaskCommand.java

``` java
public class EditFloatingTaskCommand extends Command {

    public static final String COMMAND_WORD = "edit-float";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the floating task identified by the index number used in the filtered floating task listing.\n"
            + "Parameters: INDEX [n-NAME] [p-PRIORITY]"
            + "Example: " + COMMAND_WORD + " 1 p-2";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Floting task edited: %1$s";

    private final int targetIndex;
    private final Optional<Name> newName;
    private final Optional<Priority> newPriority;

    public EditFloatingTaskCommand(int targetIndex, Optional<Name> newName, Optional<Priority> newPriority) {
        this.targetIndex = targetIndex;
        this.newName = newName;
        this.newPriority = newPriority;
    }

```
###### src\main\java\seedu\address\logic\commands\EditFloatingTaskCommand.java

``` java
    public Optional<Name> getNewName() {
        return newName;
    }

    public Optional<Priority> getNewPriority() {
        return newPriority;
    }

```
###### src\main\java\seedu\address\logic\commands\ListCommand.java

``` java
public class ListCommand extends Command {

    @Override
    public CommandResult execute() {
        assert model != null;
        model.setFloatingTaskFilter(null);
        model.setFloatingTaskSortComparator(new FloatingTaskPriorityComparator());
        model.setDeadlineTaskFilter(null);
        model.setDeadlineTaskSortComparator(new DeadlineTaskDueComparator());
        model.setEventTaskFilter(null);
        model.setEventTaskSortComparator(new EventTaskStartEndComparator());
        return new CommandResult("Listed all tasks.");
    }

}
```
###### src\main\java\seedu\address\logic\commands\SetDataDirectoryCommand.java

``` java
/**
 * Command that changes the directory where application data is stored.
 */
public class SetDataDirectoryCommand extends Command {

    private static final String MESSAGE_CHANGE = "Data directory changed to: %s";

    private final File newDir;

    public SetDataDirectoryCommand(File newDir) {
        assert newDir.isAbsolute();
        this.newDir = newDir;
    }

    @Override
    public CommandResult execute() {
        final File newTaskBookFile = new File(newDir, "taskbook.json");
        model.setTaskBookFilePath(newTaskBookFile.getAbsolutePath());
        return new CommandResult(String.format(MESSAGE_CHANGE, newDir.getAbsolutePath()));
    }

}
```
###### src\main\java\seedu\address\logic\Logic.java

``` java
    /** Returns the filtered list of event tasks */
    ObservableList<Optional<EventTask>> getFilteredEventTaskList();

}
```
###### src\main\java\seedu\address\logic\LogicManager.java

``` java
    private void updateTaskBookStorage(TaskBookChangeListener listener) {
        try {
            if (listener.getHasChanged()) {
                logger.info("Task book data changed, saving to file");
                storage.saveTaskBook(model.getTaskBook());
            }
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    private void updateConfigStorage(Config oldConfig) {
        final ReadOnlyConfig newConfig = model.getConfig();
        try {
            if (!oldConfig.equals(newConfig)) {
                logger.info("Config changed, saving to file");
                storage.saveConfig(newConfig);
            }

            if (!oldConfig.getTaskBookFilePath().equals(newConfig.getTaskBookFilePath())) {
                logger.info("Task book file path changed, moving task book");
                storage.moveTaskBook(newConfig.getTaskBookFilePath());
            }
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

```
###### src\main\java\seedu\address\logic\LogicManager.java

``` java
    @Override
    public ObservableList<Optional<DeadlineTask>> getFilteredDeadlineTaskList() {
        return model.getFilteredDeadlineTaskList();
    }

```
###### src\main\java\seedu\address\logic\parser\AddDeadlineParser.java

``` java
    @Override
    public AddDeadlineCommand parse(String str) throws ParseException {
        // Tell date/time parsers the current time
        final LocalDateTime now = referenceDateTime.orElse(LocalDateTime.now());
        dateTimeArg.setReferenceDateTime(now);

        // Parse command
        cmdParser.parse(str);

        final LocalDate date = dateTimeArg.getDate().orElse(now.toLocalDate());
        final LocalTime time = dateTimeArg.getTime().orElse(LocalTime.of(23, 59));
        final DeadlineTask toAdd = new DeadlineTask(nameArg.getValue(), LocalDateTime.of(date, time));
        return new AddDeadlineCommand(toAdd);
    }

}
```
###### src\main\java\seedu\address\logic\parser\AddEventParser.java

``` java
/**
 * Parser for {@link AddEventCommand}
 */
public class AddEventParser implements Parser<AddEventCommand> {

    private final Argument<Name> nameArg = new Argument<>("NAME", new NameParser());
    private final DateTimeArgument startArg = new DateTimeArgument("START_DATE", "END_DATE");
    private final DateTimeArgument endArg = new DateTimeArgument("END_DATE", "END_TIME");
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                        .addArgument(nameArg)
                                                        .addArgument(startArg)
                                                        .addArgument("to")
                                                        .addArgument(endArg);

    private final Optional<LocalDateTime> referenceDateTime;

    public AddEventParser() {
        this(Optional.empty());
    }

    public AddEventParser(LocalDateTime referenceDateTime) {
        this(Optional.of(referenceDateTime));
    }

    public AddEventParser(Optional<LocalDateTime> referenceDateTime) {
        this.referenceDateTime = referenceDateTime;
    }

    @Override
    public AddEventCommand parse(String str) throws ParseException {
        // Tell date/time parsers the current time
        final LocalDateTime now = referenceDateTime.orElse(LocalDateTime.now());
        startArg.setReferenceDateTime(now);
        endArg.setReferenceDateTime(now);

        // Parse command
        cmdParser.parse(str);

        final LocalDateTimeDuration duration = makeDuration(now);
        final EventTask toAdd = new EventTask(nameArg.getValue(), duration);
        return new AddEventCommand(toAdd);
    }

    private LocalDateTimeDuration makeDuration(LocalDateTime now) throws ParseException {
        final LocalDate startDate = startArg.getDate().orElse(now.toLocalDate());
        final LocalTime startTime = startArg.getTime().orElse(LocalTime.of(0, 0));
        final LocalDate endDate = endArg.getDate().orElse(startDate);
        final LocalTime endTime = endArg.getTime().orElse(LocalTime.of(23, 59));
        try {
            return new LocalDateTimeDuration(LocalDateTime.of(startDate, startTime),
                                             LocalDateTime.of(endDate, endTime));
        } catch (IllegalValueException e) {
            throw new ParseExceptionBuilder(e)
                    .addRangeOptional(startArg.getDateRange())
                    .addRangeOptional(startArg.getTimeRange())
                    .addRangeOptional(endArg.getDateRange())
                    .addRangeOptional(endArg.getTimeRange())
                    .build();
        }
    }

}
```
###### src\main\java\seedu\address\logic\parser\AddFloatingTaskParser.java

``` java
public class AddFloatingTaskParser implements Parser<AddFloatingTaskCommand> {

    private final Argument<Name> nameArg = new Argument<>("NAME", new NameParser());
    private final OptionalFlag<Priority> priorityFlag = new OptionalFlag<>("p-", "PRIORITY", new PriorityParser());
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                    .addArgument(nameArg)
                                                    .putFlag(priorityFlag);

    @Override
    public AddFloatingTaskCommand parse(String str) throws ParseException {
        cmdParser.parse(str);

        final FloatingTask toAdd;
        try {
            toAdd = new FloatingTask(nameArg.getValue(),
                                     priorityFlag.getValue().orElse(new Priority("0")));
        } catch (IllegalValueException e) {
            throw new AssertionError("Should not happen", e);
        }
        return new AddFloatingTaskCommand(toAdd);
    }

}
```
###### src\main\java\seedu\address\logic\parser\AddTaskParser.java

``` java
    public AddTaskParser(LocalDateTime referenceDateTime) {
        this(Optional.of(referenceDateTime));
    }

    public AddTaskParser(Optional<LocalDateTime> referenceDateTime) {
        overloadParser = new OverloadParser<AddTaskCommand>()
                            .addParser("Add an event", new AddEventParser(referenceDateTime))
                            .addParser("Add a deadline", new AddDeadlineParser(referenceDateTime))
                            .addParser("Add a floating task", new AddFloatingTaskParser());
    }

    @Override
    public AddTaskCommand parse(String str) throws ParseException {
        return overloadParser.parse(str);
    }
}
```
###### src\main\java\seedu\address\logic\parser\ClearCommandParser.java

``` java
public class ClearCommandParser implements Parser<ClearCommand> {

    private final CommandLineParser cmdParser = new CommandLineParser();

    @Override
    public ClearCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new ClearCommand();
    }

}
```
###### src\main\java\seedu\address\logic\parser\CommandLineParser.java

``` java
/**
 * A utility class that uses a {@link CommandLineScanner} to parse a string, breaking it down into its
 * individual {@link CommandLineParser.Argument} and {@link CommandLineParser.Flag}
 */
public class CommandLineParser {

    private static String MSG_ARG_NOT_PROVIDED = "Required argument not provided: %s";
    private static String MSG_FLAG_NOT_PROVIDED = "Required flag not provided: %s%s";
    private static String MSG_EXPECTED_KEYWORD = "Expected keyword: %s";
    private static String MSG_TOO_MANY_ARGS = "Too many arguments";
    private static String MSG_FLAG_MULTIPLE = "%s specified multiple times";

    private final List<ArgumentParser> arguments = new ArrayList<>();
    private final Map<String, FlagParser> flags = new HashMap<>();

    public CommandLineParser addArgument(ArgumentParser argument) {
        arguments.add(argument);
        return this;
    }

    public CommandLineParser addArgument(String keyword) {
        Parser<Object> parser = str -> {
            if (str.equals(keyword)) {
                return new Object(); // dummy object
            } else {
                SubstringRange range = new SubstringRange(0, str.length());
                throw new ParseException(String.format(MSG_EXPECTED_KEYWORD, keyword), range);
            }
        };
        arguments.add(new Argument<Object>(keyword, parser));
        return this;
    }

    public CommandLineParser putFlag(FlagParser flag) {
        flags.put(flag.getPrefix(), flag);
        return this;
    }

    private Collection<String> getPrefixesForFlags() {
        return flags.values().stream().map(flag -> flag.getPrefix()).collect(Collectors.toList());
    }

    public void parse(String str) throws ParseException {
        CommandLineScanner scanner = new CommandLineScanner(str, getPrefixesForFlags());

        // Reset all argument parsers
        for (ArgumentParser argument : arguments) {
            argument.reset();
        }

        // Reset all flag parsers
        for (FlagParser flag : flags.values()) {
            flag.reset();
        }

        // Parse arguments
        for (ArgumentParser argument : arguments) {
            argument.parse(scanner);
        }

        if (!flags.isEmpty()) {
            // Parse flags
            Optional<CommandLineScanner.Flag> scannerFlag;
            while ((scannerFlag = scanner.nextFlag()).isPresent()) {
                FlagParser flag = flags.get(scannerFlag.get().prefix);
                assert flag != null; // CommandLineScanner should only return flags it recognizes
                flag.parseFlag(scannerFlag.get());
            }

            // Any non-optional flags that are not specified?
            for (FlagParser flag : flags.values()) {
                if (!flag.isOptional() && !flag.isPresent()) {
                    throw new ParseException(String.format(MSG_FLAG_NOT_PROVIDED, flag.getPrefix(), flag.getName()));
                }
            }
        } else {
            // Do we have any extra arguments that should not be there?
            scanner.skipWhitespace();
            if (!scanner.getRemainingInput().isEmpty()) {
                SubstringRange range = new SubstringRange(scanner.getInputPosition(), scanner.getInput().length());
                throw new ParseException(MSG_TOO_MANY_ARGS, range);
            }
        }
    }

    public interface ArgumentParser {
        /** Name of the argument. */
        String getName();

        /** Resets the parser */
        default void reset() {}

        /** Scans and parses in input from the provided {@link CommandLineScanner}. */
        void parse(CommandLineScanner scanner) throws ParseException;
    }

    public static class Argument<T> implements ArgumentParser {
        private final String name;
        private Parser<? extends T> parser;
        private boolean present;
        private T value;
        private SubstringRange range;

        public Argument(String name, Parser<? extends T> parser) {
            assert !CollectionUtil.isAnyNull(name, parser);
            this.name = name;
            this.parser = parser;
        }

        @Override
        public String getName() {
            return name;
        }

        public void setParser(Parser<? extends T> parser) {
            assert parser != null;
            this.parser = parser;
        }

        public boolean isPresent() {
            return present;
        }

        public void set(T value, SubstringRange range) {
            assert !CollectionUtil.isAnyNull(value, range);
            this.value = value;
            this.range = range;
            present = true;
        }

        public void reset() {
            present = false;
            value = null;
            range = null;
        }

        public T getValue() {
            assert present;
            return value;
        }

        public SubstringRange getRange() {
            assert present;
            return range;
        }

        /**
         * Parses the provided {@link CommandLineScanner.Argument}.
         */
        public void parse(CommandLineScanner.Argument arg) throws ParseException {
            final T value;
            try {
                value = parser.parse(arg.value);
            } catch (ParseException e) {
                final ParseExceptionBuilder builder = new ParseExceptionBuilder(e);
                builder.prependMessage(getName() + ": ");
                if (arg.quoted) {
                    builder.clearRanges()
                            .addRange(arg.range);
                } else {
                    builder.indentRanges(arg.range.getStart());
                }
                throw builder.build();
            }
            set(value, arg.range);
        }

        @Override
        public void parse(CommandLineScanner scanner) throws ParseException {
            Optional<CommandLineScanner.Argument> arg = scanner.peekNextArgument();
            if (!arg.isPresent()) {
                SubstringRange range = new SubstringRange(scanner.getInputPosition(), scanner.getInput().length());
                throw new ParseException(String.format(MSG_ARG_NOT_PROVIDED, name), range);
            }
            parse(arg.get());
            scanner.nextArgument();
        }
    }

    public static class RestArgument<T> extends Argument<T> {
        public RestArgument(String name, Parser<? extends T> parser) {
            super(name, parser);
        }

        @Override
        public void parse(CommandLineScanner scanner) throws ParseException {
            parse(scanner.nextRestArgument());
        }
    }

    public interface FlagParser {
        /** Returns the flag prefix */
        String getPrefix();

        /** Returns the flag name */
        String getName();

        /** Resets the flag parsing state */
        default void reset() {}

        /** Returns true if the flag is optional */
        boolean isOptional();

        /** Returns true if the flag has a value */
        boolean isPresent();

        /** Parses the {@link CommandLineScanner.Flag} */
        void parseFlag(CommandLineScanner.Flag flag) throws ParseException;
    }

    private abstract static class BaseFlag<T> implements FlagParser {

        private final String prefix;
        private final String name;
        private Parser<? extends T> parser;
        protected T value;
        protected boolean present;
        protected SubstringRange range;

        protected BaseFlag(String prefix, String name, Parser<? extends T> parser) {
            assert !CollectionUtil.isAnyNull(prefix, name, parser);
            this.prefix = prefix;
            this.name = name;
            this.parser = parser;
        }

        @Override
        public String getPrefix() {
            return prefix;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public boolean isPresent() {
            return present;
        }

        public void setParser(Parser<? extends T> parser) {
            assert parser != null;
            this.parser = parser;
        }

        @Override
        public void reset() {
            present = false;
        }

        @Override
        public void parseFlag(CommandLineScanner.Flag flag) throws ParseException {
            assert flag.prefix.equals(prefix);
            if (present) {
                throw new ParseException(String.format(MSG_FLAG_MULTIPLE, prefix), flag.range);
            }
            try {
                value = parser.parse(flag.value);
            } catch (ParseException e) {
                if (flag.quoted) {
                    throw new ParseException(e.getMessage(), e, flag.range);
                } else {
                    throw e.indentRanges(flag.range.getStart());
                }
            }
            present = true;
            range = flag.range;
        }

    }

    public static class Flag<T> extends BaseFlag<T> {

        public Flag(String prefix, String name, Parser<? extends T> parser) {
            super(prefix, name, parser);
        }

        public T getValue() {
            assert present;
            return value;
        }

        public SubstringRange getRange() {
            assert present;
            return range;
        }

        @Override
        public boolean isOptional() {
            return false;
        }

    }

    public static class OptionalFlag<T> extends BaseFlag<T> {

        public OptionalFlag(String prefix, String name, Parser<? extends T> parser) {
            super(prefix, name, parser);
        }

        public Optional<T> getValue() {
            return isPresent() ? Optional.of(value) : Optional.empty();
        }

        public Optional<SubstringRange> getRange() {
            return isPresent() ? Optional.of(range) : Optional.empty();
        }

        @Override
        public boolean isOptional() {
            return true;
        }

    }

}
```
###### src\main\java\seedu\address\logic\parser\CommandLineScanner.java

``` java
/**
 * Tokenizes command line strings made up of zero or more of the following:
 *
 * <ul>
 * <li>Quoted strings, which are surrounded by quotes (e.g. <code>"quoted string"</code>).
 * Use backslashes to embed quotes inside the string. (e.g. <code>"escaped \" backslash"</code>).</li>
 * <li>Unquoted strings, which are surrounded by word boundaries. (e.g. <code>word</code> is a single
 * unquoted string, while <code>two words</code> are two unquoted strings.</li>
 * <li>Arguments, which are either quoted or unquoted strings that must come before flags.</li>
 * <li>A single rest argument, which is either a quoted string or multiple unquoted strings that come before
 * flags.</li>
 * <li>Flags, which are strings which have prefix which belong to the list of <code>flagPrefixes</code></li>
 * </ul>
 */
public class CommandLineScanner {

    /** Pattern for parsing unquoted strings */
    private static Pattern PAT_UNQUOTED = Pattern.compile("^(?<unquotedString>[^\\s]+)");

    /** Pattern for parsing quoted strings */
    private static Pattern PAT_QUOTED = Pattern.compile("^\"(?<quotedString>(?:\\\\\"|[^\"])*)\"");

    private final String input;

    private int inputPosition;

    private final List<String> flagPrefixes;

    public CommandLineScanner(String input, Collection<String> flagPrefixes) {
        assert input != null;
        this.input = input;
        this.flagPrefixes = new ArrayList<>(flagPrefixes);
    }

    public CommandLineScanner(String input) {
        this(input, Collections.emptyList());
    }

    public CommandLineScanner(CommandLineScanner toBeCopied) {
        this(toBeCopied.input, toBeCopied.flagPrefixes);
        this.inputPosition = toBeCopied.inputPosition;
    }

    public String getInput() {
        return input;
    }

    public Collection<String> getFlagPrefixes() {
        return Collections.unmodifiableList(flagPrefixes);
    }

    public int getInputPosition() {
        return inputPosition;
    }

    /**
     * Returns the substring of input that has not been processed yet.
     */
    public String getRemainingInput() {
        return input.substring(inputPosition);
    }

    /**
     * Attempts to match the string with a flag prefix, and returns the first successfully matched one.
     */
    private Optional<String> matchFlagPrefix(String str) {
        for (String flagPrefix : flagPrefixes) {
            if (str.startsWith(flagPrefix)) {
                return Optional.of(flagPrefix);
            }
        }
        return Optional.empty();
    }

    /**
     * Skip over whitespace in the input, if any.
     */
    public void skipWhitespace() {
        while (inputPosition < input.length() && Character.isWhitespace(input.charAt(inputPosition))) {
            inputPosition++;
        }
    }

    /**
     * Returns the next unquoted string (if any).
     */
    public Optional<String> nextUnquotedString() {
        skipWhitespace();
        final Matcher matcher = PAT_UNQUOTED.matcher(input);
        matcher.region(inputPosition, input.length());
        if (matcher.find()) {
            inputPosition = matcher.end();
            return Optional.of(matcher.group("unquotedString"));
        } else {
            return Optional.empty();
        }
    }

    /**
     * Returns the next unquoted string (if any), but does not advance the input position.
     */
    public Optional<String> peekNextUnquotedString() {
        return new CommandLineScanner(this).nextUnquotedString();
    }

    /**
     * Returns the next quoted string (if any).
     */
    public Optional<String> nextQuotedString() {
        skipWhitespace();
        final Matcher matcher = PAT_QUOTED.matcher(input);
        matcher.region(inputPosition, input.length());
        if (matcher.find()) {
            inputPosition = matcher.end();
            return Optional.of(unescapeQuotes(matcher.group("quotedString")));
        } else {
            return Optional.empty();
        }
    }

    private String unescapeQuotes(String str) {
        return str.replaceAll("\\\\\"", "\"");
    }

    /**
     * Returns the next quoted string (if any), but does not advance the input position.
     */
    public Optional<String> peekNextQuotedString() {
        return new CommandLineScanner(this).nextQuotedString();
    }

    /**
     * Returns the next argument (if any).
     */
    public Optional<Argument> nextArgument() {
        Optional<String> value;
        skipWhitespace();
        int startInputPosition = inputPosition;
        if ((value = nextQuotedString()).isPresent()) {
            return Optional.of(new Argument(value.get(), startInputPosition, inputPosition, true));
        } else if ((value = nextUnquotedString()).isPresent()) {
            if (matchFlagPrefix(value.get()).isPresent()) {
                return Optional.empty();
            } else {
                return Optional.of(new Argument(value.get(), startInputPosition, inputPosition, false));
            }
        } else {
            return Optional.empty();
        }
    }

    /**
     * Returns the next argument (if any), but does not advance the input position.
     */
    public Optional<Argument> peekNextArgument() {
        return new CommandLineScanner(this).nextArgument();
    }

    /**
     * Returns the "rest argument", which is either:
     * 1. A single quoted argument.
     * 2. Or the reset of the input until the next flag as a single argument.
     */
    public Argument nextRestArgument() {
        skipWhitespace();
        int startPosition = inputPosition;
        Optional<String> quotedString = nextQuotedString();
        if (quotedString.isPresent()) {
            return new Argument(quotedString.get(), startPosition, inputPosition, true);
        } else {
            while (!matchFlagPrefix(getRemainingInput()).isPresent()) {
                if (!nextUnquotedString().isPresent()) {
                    break;
                }
                skipWhitespace();
            }
            String value = input.substring(startPosition, inputPosition);
            String trimmedValue = value.trim();
            int endPosition = inputPosition - (value.length() - trimmedValue.length());
            return new Argument(trimmedValue, startPosition, endPosition, false);
        }
    }

    /**
     * Returns the next flag (if any).
     * @throws ParseException if the input cannot be parsed as a flag
     */
    public Optional<Flag> nextFlag() throws ParseException {
        skipWhitespace();
        if (getRemainingInput().isEmpty()) {
            return Optional.empty();
        }
        Optional<String> flagPrefix = matchFlagPrefix(getRemainingInput());
        if (flagPrefix.isPresent()) {
            inputPosition += flagPrefix.get().length();
            if (peekNextQuotedString().isPresent()) {
                skipWhitespace();
                int startPosition = inputPosition;
                String value = nextQuotedString().get();
                return Optional.of(new Flag(flagPrefix.get(), value, startPosition, inputPosition, true));
            } else {
                Argument rest = nextRestArgument();
                return Optional.of(new Flag(flagPrefix.get(), rest.value, rest.range, false));
            }
        } else {
            String flag = peekNextUnquotedString().orElse("");
            throw new ParseException("not a flag: " + flag, new SubstringRange(inputPosition, input.length()));
        }
    }

    public static final class Argument {
        public final String value;
        public final SubstringRange range;
        public final boolean quoted;

        public Argument(String value, SubstringRange range, boolean quoted) {
            this.value = value;
            this.range = range;
            this.quoted = quoted;
        }

        public Argument(String value, int start, int end, boolean quoted) {
            this(value, new SubstringRange(start, end), quoted);
        }

        @Override
        public boolean equals(Object other) {
            return other == this
                    || (other instanceof Argument
                    && value.equals(((Argument)other).value)
                    && range.equals(((Argument)other).range)
                    && quoted == ((Argument)other).quoted
                    );
        }

        @Override
        public String toString() {
            return MoreObjects.toStringHelper(this)
                    .add("value", value)
                    .add("range", range)
                    .add("quoted", quoted)
                    .toString();
        }
    }

    public static final class Flag {
        public final String prefix;
        public final String value;
        public final SubstringRange range;
        public final boolean quoted;

        public Flag(String prefix, String value, SubstringRange range, boolean quoted) {
            this.prefix = prefix;
            this.value = value;
            this.range = range;
            this.quoted = quoted;
        }

        public Flag(String prefix, String value, int start, int end, boolean quoted) {
            this(prefix, value, new SubstringRange(start, end), quoted);
        }

        @Override
        public boolean equals(Object other) {
            return other == this
                    || (other instanceof Flag
                    && prefix.equals(((Flag)other).prefix)
                    && value.equals(((Flag)other).value)
                    && range.equals(((Flag)other).range)
                    && quoted == ((Flag)other).quoted
                    );
        }

        @Override
        public String toString() {
            return MoreObjects.toStringHelper(this)
                    .add("prefix", prefix)
                    .add("value", value)
                    .add("range", range)
                    .add("quoted", quoted)
                    .toString();
        }

    }

}
```
###### src\main\java\seedu\address\logic\parser\DateParser.java

``` java
/**
 * A parser for dates in day/month/year format.
 */
public class DateParser implements Parser<LocalDate> {

    private final LocalDate referenceDate;

    private final DateTimeFormatter dateFormatter;

    public DateParser(LocalDate referenceDate) {
        this.referenceDate = referenceDate;
        dateFormatter = new DateTimeFormatterBuilder()
                .appendPattern("d[/M[/uuuu]]")
                .parseDefaulting(ChronoField.MONTH_OF_YEAR, this.referenceDate.getMonthValue())
                .parseDefaulting(ChronoField.YEAR, this.referenceDate.getYear())
                .toFormatter();
    }

    public DateParser() {
        this(LocalDate.now());
    }

    public LocalDate getReferenceDate() {
        return referenceDate;
    }

    @Override
    public LocalDate parse(String str) throws ParseException {
        final Optional<LocalDate> nameDate = parseAsName(str.trim());
        if (nameDate.isPresent()) {
            return nameDate.get();
        }
        try {
            return LocalDate.parse(str.trim(), dateFormatter);
        } catch (DateTimeParseException e) {
            throw new ParseException(e.toString(), e, SubstringRange.of(str));
        }
    }

    private Optional<LocalDate> parseAsName(String name) {
        switch (name) {
        case "tdy": // today
            return Optional.of(referenceDate);
        case "tmr": // tomorrow
            return Optional.of(referenceDate.plusDays(1));
        case "yst": // yesterday
            return Optional.of(referenceDate.minusDays(1));
        default:
            return Optional.empty();
        }
    }

}
```
###### src\main\java\seedu\address\logic\parser\DateTimeArgument.java

``` java
public class DateTimeArgument implements CommandLineParser.ArgumentParser {

    private final Argument<LocalDate> dateArg;
    private final Argument<LocalTime> timeArg;

    public DateTimeArgument(String dateName, String timeName) {
        this.dateArg = new Argument<>(dateName, new DateParser());
        this.timeArg = new Argument<>(timeName, new TimeParser());
    }

    public Optional<LocalDate> getDate() {
        return dateArg.isPresent() ? Optional.of(dateArg.getValue()) : Optional.empty();
    }

    public Optional<SubstringRange> getDateRange() {
        return dateArg.isPresent() ? Optional.of(dateArg.getRange()) : Optional.empty();
    }

    public Optional<LocalTime> getTime() {
        return timeArg.isPresent() ? Optional.of(timeArg.getValue()) : Optional.empty();
    }

    public Optional<SubstringRange> getTimeRange() {
        return timeArg.isPresent() ? Optional.of(timeArg.getRange()) : Optional.empty();
    }

    public void setReferenceDateTime(LocalDateTime referenceDateTime) {
        dateArg.setParser(new DateParser(referenceDateTime.toLocalDate()));
        timeArg.setParser(new TimeParser(referenceDateTime.toLocalTime()));
    }

    @Override
    public String getName() {
        return dateArg.getName() + " " + timeArg.getName();
    }

    @Override
    public void reset() {
        dateArg.reset();
        timeArg.reset();
    }

    @Override
    public void parse(CommandLineScanner scanner) throws ParseException {
        try {
            dateArg.parse(scanner);
        } catch (ParseException e) {
            // Okay for now
        }
        try {
            timeArg.parse(scanner);
        } catch (ParseException e) {
            if (!dateArg.isPresent()) {
                throw e;
            }
        }
    }

}
```
###### src\main\java\seedu\address\logic\parser\DeleteCommandParser.java

``` java
/**
 * Parser for the "del" command.
 */
public class DeleteCommandParser implements Parser<Command> {

    private final OverloadParser<Command> overloadParser = new OverloadParser<Command>()
            .addParser("Delete an event", new DeleteEventParser())
            .addParser("Delete a deadline", new DeleteDeadlineParser())
            .addParser("Delete a floating task", new DeleteFloatingTaskParser());

    @Override
    public Command parse(String str) throws ParseException {
        return overloadParser.parse(str);
    }

}
```
###### src\main\java\seedu\address\logic\parser\DeleteDeadlineParser.java

``` java
public class DeleteDeadlineParser implements Parser<DeleteDeadlineCommand> {

    private final Argument<Integer> indexArg = new Argument<>("INDEX", new IndexParser(IndexPrefix.DEADLINE));
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                    .addArgument(indexArg);

    @Override
    public DeleteDeadlineCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new DeleteDeadlineCommand(indexArg.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\DeleteEventParser.java

``` java
public class DeleteEventParser implements Parser<DeleteEventCommand> {

    private final Argument<Integer> indexArg = new Argument<>("INDEX", new IndexParser(IndexPrefix.EVENT));
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                    .addArgument(indexArg);

    @Override
    public DeleteEventCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new DeleteEventCommand(indexArg.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\DeleteFloatingTaskParser.java

``` java
/**
 * Parser for "del-float" command.
 */
public class DeleteFloatingTaskParser implements Parser<DeleteFloatingTaskCommand> {

    private final Argument<Integer> indexArg = new Argument<>("INDEX", new IndexParser(IndexPrefix.FLOAT));
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                    .addArgument(indexArg);

    @Override
    public DeleteFloatingTaskCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new DeleteFloatingTaskCommand(indexArg.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\EditCommandParser.java

``` java
public class EditCommandParser implements Parser<Command> {

    private final OverloadParser<Command> overloadParser;

    public EditCommandParser() {
        this(Optional.empty());
    }

    public EditCommandParser(LocalDateTime referenceDateTime) {
        this(Optional.of(referenceDateTime));
    }

    public EditCommandParser(Optional<LocalDateTime> referenceDateTime) {
        overloadParser = new OverloadParser<Command>()
                            .addParser("Edit an event", new EditEventParser(referenceDateTime))
                            .addParser("Edit a deadline", new EditDeadlineParser(referenceDateTime))
                            .addParser("Edit a floating task", new EditFloatingTaskParser());
    }

    @Override
    public Command parse(String str) throws ParseException {
        return overloadParser.parse(str);
    }

}
```
###### src\main\java\seedu\address\logic\parser\EditDeadlineParser.java

``` java
    @Override
    public EditDeadlineCommand parse(String str) throws ParseException {
        // Tell date/time parsers the current time
        final LocalDateTime now = referenceDateTime.orElse(LocalDateTime.now());
        newDateFlag.setParser(new DateParser(now.toLocalDate()));
        newTimeFlag.setParser(new TimeParser(now.toLocalTime()));

        cmdParser.parse(str);

        return new EditDeadlineCommand(indexArg.getValue(), newNameFlag.getValue(), newDateFlag.getValue(),
                                       newTimeFlag.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\EditEventParser.java

``` java
public class EditEventParser implements Parser<EditEventCommand> {

    private final Argument<Integer> indexArg = new Argument<>("INDEX", new IndexParser(IndexPrefix.EVENT));
    private final OptionalFlag<LocalDate> newStartDateFlag = new OptionalFlag<>("sd-", "NEW_START_DATE", new DateParser());
    private final OptionalFlag<LocalTime> newStartTimeFlag = new OptionalFlag<>("st-", "NEW_START_TIME", new TimeParser());
    private final OptionalFlag<LocalDate> newEndDateFlag = new OptionalFlag<>("ed-", "NEW_END_DATE", new DateParser());
    private final OptionalFlag<LocalTime> newEndTimeFlag = new OptionalFlag<>("et-", "NEW_END_TIME", new TimeParser());
    private final OptionalFlag<Name> newNameFlag = new OptionalFlag<>("n-", "NEW_NAME", new NameParser());
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                        .addArgument(indexArg)
                                                        .putFlag(newStartDateFlag)
                                                        .putFlag(newStartTimeFlag)
                                                        .putFlag(newEndDateFlag)
                                                        .putFlag(newEndTimeFlag)
                                                        .putFlag(newNameFlag);

    private final Optional<LocalDateTime> referenceDateTime;

    public EditEventParser() {
        this(Optional.empty());
    }

    public EditEventParser(LocalDateTime referenceDateTime) {
        this(Optional.of(referenceDateTime));
    }

    public EditEventParser(Optional<LocalDateTime> referenceDateTime) {
        this.referenceDateTime = referenceDateTime;
    }

    @Override
    public EditEventCommand parse(String str) throws ParseException {
        // Tell date/time parsers the current time
        final LocalDateTime now = referenceDateTime.orElse(LocalDateTime.now());
        newStartDateFlag.setParser(new DateParser(now.toLocalDate()));
        newStartTimeFlag.setParser(new TimeParser(now.toLocalTime()));
        newEndDateFlag.setParser(new DateParser(now.toLocalDate()));
        newEndTimeFlag.setParser(new TimeParser(now.toLocalTime()));

        cmdParser.parse(str);

        return new EditEventCommand(indexArg.getValue(), newNameFlag.getValue(), newStartDateFlag.getValue(),
                                    newStartTimeFlag.getValue(), newEndDateFlag.getValue(),
                                    newEndTimeFlag.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\EditFloatingTaskParser.java

``` java
public class EditFloatingTaskParser implements Parser<EditFloatingTaskCommand> {

    private final Argument<Integer> indexArg = new Argument<>("INDEX", new IndexParser(IndexPrefix.FLOAT));
    private final OptionalFlag<Name> newNameFlag = new OptionalFlag<>("n-", "NEW_NAME", new NameParser());
    private final OptionalFlag<Priority> newPriorityFlag = new OptionalFlag<>("p-", "NEW_PRIORITY", new PriorityParser());
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                        .addArgument(indexArg)
                                                        .putFlag(newNameFlag)
                                                        .putFlag(newPriorityFlag);

    @Override
    public EditFloatingTaskCommand parse(String args) throws ParseException {
        cmdParser.parse(args);

        return new EditFloatingTaskCommand(indexArg.getValue(), newNameFlag.getValue(),
                                           newPriorityFlag.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\ExitCommandParser.java

``` java
public class ExitCommandParser implements Parser<ExitCommand> {

    private final CommandLineParser cmdParser = new CommandLineParser();

    @Override
    public ExitCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new ExitCommand();
    }

}
```
###### src\main\java\seedu\address\logic\parser\FileParser.java

``` java
/**
 * Parser that parses a valid file path string.
 */
public class FileParser implements Parser<File> {

    @Override
    public File parse(String str) throws ParseException {
        if (str.trim().isEmpty()) {
            throw new ParseException("path cannot be empty", SubstringRange.of(str));
        }
        try {
            return Paths.get(str.trim()).toFile();
        } catch (InvalidPathException e) {
            throw new ParseException(e.getMessage(), e, SubstringRange.of(str));
        }
    }

}
```
###### src\main\java\seedu\address\logic\parser\HelpCommandParser.java

``` java
public class HelpCommandParser implements Parser<HelpCommand> {

    private final CommandLineParser cmdParser = new CommandLineParser();

    @Override
    public HelpCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new HelpCommand();
    }

}
```
###### src\main\java\seedu\address\logic\parser\IndexParser.java

``` java
/**
 * Parses a task index of format <code>&lt;PREFIX&gt;&lt;INDEX&gt;</code>, where
 * <code>&lt;PREFIX&gt;</code> is a prefix which the index must have, and <code>&lt;INDEX&gt;</code>
 * is a 1-index signed integer index.
 */
public class IndexParser implements Parser<Integer> {

    private static final String MSG_NO_PREFIX = "%2$s must start with \"%1$s\"";
    private static final String MSG_NOT_INDEX = "invalid %2$s: %3$s";

    private final String prefix;
    private final String name;

    public IndexParser(String prefix, String name) {
        CollectionUtil.isAnyNull(prefix, name);
        this.prefix = prefix;
        this.name = name;
    }

    public IndexParser(IndexPrefix prefix) {
        this(prefix.getPrefixString(), prefix.getName());
    }

    @Override
    public Integer parse(String str) throws ParseException {
        assert str != null;
        if (!str.startsWith(prefix)) {
            throw new ParseException(String.format(MSG_NO_PREFIX, prefix, name),
                                     new SubstringRange(0, Math.min(prefix.length(), str.length())));
        }

        String indexStr = str.substring(prefix.length());
        if (!StringUtil.isUnsignedInteger(indexStr)) {
            throw new ParseException(String.format(MSG_NOT_INDEX, prefix, name, indexStr),
                                     new SubstringRange(prefix.length(), str.length()));
        }

        return Integer.parseInt(indexStr) - 1;
    }

}
```
###### src\main\java\seedu\address\logic\parser\ListCommandParser.java

``` java
public class ListCommandParser implements Parser<ListCommand> {

    private final CommandLineParser cmdParser = new CommandLineParser();

    @Override
    public ListCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new ListCommand();
    }

}
```
###### src\main\java\seedu\address\logic\parser\MarkDeadlineFinishedParser.java

``` java
public class MarkDeadlineFinishedParser implements Parser<MarkDeadlineFinishedCommand> {

    private final Argument<Integer> indexArg = new Argument<>("INDEX", new IndexParser(IndexPrefix.DEADLINE));
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                    .addArgument(indexArg);

    @Override
    public MarkDeadlineFinishedCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new MarkDeadlineFinishedCommand(indexArg.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\MarkFinishedCommandParser.java

``` java
public class MarkFinishedCommandParser implements Parser<Command> {

    private final OverloadParser<Command> overloadParser = new OverloadParser<Command>()
            .addParser("Mark a deadline as finished", new MarkDeadlineFinishedParser())
            .addParser("Mark a floating task as finished", new MarkFloatingTaskFinishedParser());

    @Override
    public Command parse(String str) throws ParseException {
        return overloadParser.parse(str);
    }

}
```
###### src\main\java\seedu\address\logic\parser\MarkFloatingTaskFinishedParser.java

``` java
public class MarkFloatingTaskFinishedParser implements Parser<MarkFloatingTaskFinishedCommand> {

    private final Argument<Integer> indexArg = new Argument<>("INDEX", new IndexParser(IndexPrefix.FLOAT));
    private final CommandLineParser cmdParser = new CommandLineParser()
                                                    .addArgument(indexArg);

    @Override
    public MarkFloatingTaskFinishedCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new MarkFloatingTaskFinishedCommand(indexArg.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\NameParser.java

``` java
/**
 * A parser that parses a string {@link Name}.
 */
public class NameParser implements Parser<Name> {

    @Override
    public Name parse(String str) throws ParseException {
        try {
            return new Name(str);
        } catch (IllegalValueException e) {
            throw new ParseException(e.getMessage(), e, SubstringRange.of(str));
        }
    }

}
```
###### src\main\java\seedu\address\logic\parser\OverloadParser.java

``` java
/**
 * A parser that tries to parse the input string with multiple parsers, and returns the first successful
 * result.
 */
public class OverloadParser<T> implements Parser<T> {

    private final List<Candidate<T>> candidates = new ArrayList<>();

    public OverloadParser<T> addParser(String name, Parser<? extends T> parser) {
        candidates.add(new Candidate<T>(name, parser));
        return this;
    }

    @Override
    public T parse(String str) throws ParseException {
        List<CandidateException> candidateExceptions = new ArrayList<>();

        // Try all parsers, while collecting their exceptions
        for (Candidate<T> candidate : candidates) {
            try {
                return candidate.parser.parse(str);
            } catch (ParseException e) {
                candidateExceptions.add(new CandidateException(candidate.name, e));
            }
        }

        throw makeParseException(candidateExceptions);
    }

    private ParseException makeParseException(List<CandidateException> candidateExceptions) {
        final ParseExceptionBuilder builder = new ParseExceptionBuilder("Tried to parse the input as the following but failed:");
        for (CandidateException candidateException : candidateExceptions) {
            builder.appendMessage("\n\n").appendMessage(candidateException.name).appendMessage(":\n    ")
                .appendMessage(candidateException.exception.getMessage());
            builder.addRanges(candidateException.exception.getRanges());
        }
        return builder.build();
    }

    private static class Candidate<T> {
        final String name;
        final Parser<? extends T> parser;

        Candidate(String name, Parser<? extends T> parser) {
            this.name = name;
            this.parser = parser;
        }
    }

    private static class CandidateException {
        final String name;
        final ParseException exception;

        CandidateException(String name, ParseException exception) {
            this.name = name;
            this.exception = exception;
        }
    }

}
```
###### src\main\java\seedu\address\logic\parser\ParseException.java

``` java
/**
 * Signals that a string input could not be parsed.
 */
public class ParseException extends IllegalValueException {

    private final List<SubstringRange> ranges = new ArrayList<>();

    /**
     * @param message should contain relevant information on why the input is invalid.
     * @param ranges substring range(s) of the invalid input.
     */
    public ParseException(String message, Collection<SubstringRange> ranges) {
        super(message);
        this.ranges.addAll(ranges);
    }

    public ParseException(String message, SubstringRange... ranges) {
        this(message, Arrays.asList(ranges));
    }

    /**
     * @param message should contain relevant information on why the input is invalid.
     * @param cause the exception which caused this exception to be thrown.
     * @param ranges substring range(s) of the invalid input.
     */
    public ParseException(String message, Throwable cause, Collection<SubstringRange> ranges) {
        super(message, cause);
        this.ranges.addAll(ranges);
    }

    public ParseException(String message, Throwable cause, SubstringRange... ranges) {
        this(message, cause, Arrays.asList(ranges));
    }

    public List<SubstringRange> getRanges() {
        return Collections.unmodifiableList(ranges);
    }

    public ParseException indentRanges(int x) {
        List<SubstringRange> newRanges = ranges.stream()
                                                .map(range -> range.indent(x))
                                                .collect(Collectors.toList());
        return new ParseException(getMessage(), this, newRanges);
    }

}
```
###### src\main\java\seedu\address\logic\parser\ParseExceptionBuilder.java

``` java
public class ParseExceptionBuilder {

    private StringBuilder message = new StringBuilder();
    private Throwable cause;
    private ArrayList<SubstringRange> ranges = new ArrayList<>();

    public ParseExceptionBuilder(String message) {
        assert message != null;
        this.message.append(message);
    }

    public ParseExceptionBuilder(Throwable cause) {
        this.message.append(cause.getMessage());
        this.cause = cause;
    }

    public ParseExceptionBuilder(ParseException cause) {
        this((Throwable)cause);
        this.ranges.addAll(cause.getRanges());
    }

    public ParseExceptionBuilder prependMessage(String message) {
        this.message.insert(0, message);
        return this;
    }

    public ParseExceptionBuilder appendMessage(String message) {
        this.message.append(message);
        return this;
    }

    public ParseExceptionBuilder addRange(SubstringRange range) {
        ranges.add(range);
        return this;
    }

    public ParseExceptionBuilder addRangeOptional(Optional<SubstringRange> range) {
        if (range.isPresent()) {
            addRange(range.get());
        }
        return this;
    }

    public ParseExceptionBuilder addRanges(Collection<SubstringRange> ranges) {
        this.ranges.addAll(ranges);
        return this;
    }

    public ParseExceptionBuilder indentRanges(int x) {
        ranges = ranges.stream()
                    .map(range -> range.indent(x))
                    .collect(Collectors.toCollection(ArrayList::new));
        return this;
    }

    public ParseExceptionBuilder clearRanges() {
        ranges.clear();
        return this;
    }

    public ParseException build() {
        return new ParseException(message.toString(), cause, ranges);
    }

}
```
###### src\main\java\seedu\address\logic\parser\Parser.java

``` java
/**
 * Represents a parser which can parse a string and produce a result of type T.
 *
 * This is a functional interface whose functional method is {@link #parse}.
 */
public interface Parser<T> {

    /**
     * Parses an input string and returns the parsed result as an object with type T.
     * @throws ParseException if the input string could not be parsed. The ranges of the ParseException will
     * contain the substring ranges of the input string which caused the parsing to fail.
     */
    T parse(String str) throws ParseException;

}
```
###### src\main\java\seedu\address\logic\parser\PriorityParser.java

``` java
public class PriorityParser implements Parser<Priority> {

    @Override
    public Priority parse(String str) throws ParseException {
        try {
            return new Priority(str);
        } catch (IllegalValueException e) {
            throw new ParseException(e.getMessage(), e, SubstringRange.of(str));
        }
    }

}
```
###### src\main\java\seedu\address\logic\parser\SetDataDirectoryParser.java

``` java
/**
 * Parser for the "setdatadir" command.
 */
public class SetDataDirectoryParser implements Parser<SetDataDirectoryCommand> {

    public static final String COMMAND_WORD = "setdatadir";

    private final RestArgument<File> newDirArg = new RestArgument<>("NEW_DIRECTORY", new FileParser());
    private final CommandLineParser cmdParser = new CommandLineParser().addArgument(newDirArg);

    @Override
    public SetDataDirectoryCommand parse(String str) throws ParseException {
        cmdParser.parse(str);
        return new SetDataDirectoryCommand(newDirArg.getValue());
    }

}
```
###### src\main\java\seedu\address\logic\parser\SubcommandParser.java

``` java
/**
 * A parser that implements subcommands (selection of parser based on first word of input)
 */
public class SubcommandParser implements Parser<Command> {

    private static final String MSG_NO_COMMAND = "No command name given";

    private static final String MSG_UNKNOWN_COMMAND = "Unknown command: %s";

    private Map<String, Parser<? extends Command>> parsers = new HashMap<>();

    public SubcommandParser putSubcommand(String name, Parser<? extends Command> parser) {
        parsers.put(name, parser);
        return this;
    }

    @Override
    public Command parse(String str) throws ParseException {
        final CommandLineScanner scanner = new CommandLineScanner(str);
        Optional<CommandLineScanner.Argument> subcommandArg = scanner.nextArgument();
        if (!subcommandArg.isPresent()) {
            throw new ParseException(MSG_NO_COMMAND, SubstringRange.of(str));
        }
        if (!parsers.containsKey(subcommandArg.get().value)) {
            throw new ParseException(String.format(MSG_UNKNOWN_COMMAND, subcommandArg.get().value),
                                     subcommandArg.get().range);
        }
        Parser<? extends Command> parser = parsers.get(subcommandArg.get().value);
        try {
            return parser.parse(scanner.getRemainingInput());
        } catch (ParseException e) {
            throw new ParseExceptionBuilder(e)
                        .prependMessage(subcommandArg.get().value + ": ")
                        .indentRanges(scanner.getInputPosition())
                        .build();
        }
    }

}
```
###### src\main\java\seedu\address\logic\parser\TimeParser.java

``` java
/**
 * A parser for 12-hour clock times.
 */
public class TimeParser implements Parser<LocalTime> {

    private static final Pattern PATTERN_TIME = Pattern.compile("(?<hour>\\d{1,2})"
            + "(?:[.:](?<minute>\\d{2}))?(?<ampm>am|pm)");

    private final LocalTime referenceTime;

    public TimeParser(LocalTime referenceTime) {
        this.referenceTime = referenceTime;
    }

    public TimeParser() {
        this(LocalTime.now());
    }

    public LocalTime getReferenceTime() {
        return referenceTime;
    }

    @Override
    public LocalTime parse(String str) throws ParseException {
        final Matcher matcher = PATTERN_TIME.matcher(str.trim());
        if (!matcher.matches()) {
            throw new ParseException("invalid time format", SubstringRange.of(str));
        }

        int hour = Integer.parseInt(matcher.group("hour"));
        if (hour > 12) {
            throw new ParseException("invalid hour: " + hour,
                                     new SubstringRange(matcher.start("hour"), matcher.end("hour")));
        } else if (hour == 12) {
            hour = 0;
        }

        final int minute = matcher.group("minute") != null ? Integer.parseInt(matcher.group("minute")) : 0;
        if (minute >= 60) {
            assert matcher.group("minute") != null;
            throw new ParseException("invalid minute: " + minute,
                                     new SubstringRange(matcher.start("minute"), matcher.end("minute")));
        }

        final boolean isPM = matcher.group("ampm").equals("pm");
        return LocalTime.of(hour + (isPM ? 12 : 0), minute);
    }

}
```
###### src\main\java\seedu\address\MainApp.java

``` java
/**
 * The main entry point to the application.
 */
public class MainApp extends Application {
    private static final Logger logger = LogsCenter.getLogger(MainApp.class);

    public static final Version VERSION = new Version(0, 3, 0, true);

    /** Name of the application */
    public static final String NAME = "Task Tracker";

    private final String configPath;
    private Ui ui;
    private Logic logic;
    private Storage storage;
    private Model model;

    public MainApp() {
        this(null);
    }

    public MainApp(String configPath) {
        this.configPath = configPath;
    }

```
###### src\main\java\seedu\address\MainApp.java

``` java
    private Model initModelManager(Storage storage, ReadOnlyConfig config) {
        Optional<ReadOnlyTaskBook> addressBookOptional;
        ReadOnlyTaskBook initialData;
        try {
            addressBookOptional = storage.readTaskBook();
            if (!addressBookOptional.isPresent()) {
                logger.info("Data file not found. Will be starting with an empty TaskBook");
            }
            initialData = addressBookOptional.orElse(new TaskBook());
        } catch (DataConversionException e) {
            logger.warning("Data file not in the correct format. Will be starting with an empty TaskBook");
            initialData = new TaskBook();
        } catch (IOException e) {
            logger.warning("Problem while reading from the file. . Will be starting with an empty TaskBook");
            initialData = new TaskBook();
        }

        return new ModelManager(config, initialData);
    }

```
###### src\main\java\seedu\address\MainApp.java

``` java
    private ConfigStorage initConfigStorage(String configFilePath) {
        if (configFilePath == null) {
            configFilePath = getApplicationParameter("config");
        }
        if (configFilePath == null) {
            configFilePath = Config.DEFAULT_CONFIG_FILE;
        } else {
            logger.info("Custom Config file specified " + configFilePath);
        }

        logger.info("Using config file: " + configFilePath);
        return new JsonConfigStorage(configFilePath);
    }

```
###### src\main\java\seedu\address\model\compare\DeadlineTaskDueComparator.java

``` java
/**
 * Compares two DeadlineTasks in the order of
 * 1. Due date
 * 2. Name
 */
public class DeadlineTaskDueComparator implements Comparator<DeadlineTask> {

    @Override
    public int compare(DeadlineTask a, DeadlineTask b) {
        return ComparisonChain.start()
                .compare(a.getDue(), b.getDue())
                .compare(a.getName().toString(), b.getName().toString())
                .result();
    }

}
```
###### src\main\java\seedu\address\model\compare\EventTaskStartEndComparator.java

``` java
/**
 * Compares two event tasks in the following order:
 * 1. Start datetime
 * 2. End datetime
 * 3. Name
 */
public class EventTaskStartEndComparator implements Comparator<EventTask> {

    @Override
    public int compare(EventTask a, EventTask b) {
        return ComparisonChain.start()
                .compare(a.getStart(), b.getStart())
                .compare(a.getEnd(), b.getEnd())
                .compare(a.getName().toString(), b.getName().toString())
                .result();
    }

}
```
###### src\main\java\seedu\address\model\compare\FloatingTaskPriorityComparator.java

``` java
/**
 * Compares two floating tasks in the order of:
 * 1. Priority (reverse order)
 * 2. Name
 */
public class FloatingTaskPriorityComparator implements Comparator<FloatingTask> {

    @Override
    public int compare(FloatingTask a, FloatingTask b) {
        return ComparisonChain.start()
                .compare(b.getPriority().toInteger(), a.getPriority().toInteger())
                .compare(a.getName().toString(), b.getName().toString())
                .result();
    }

}
```
###### src\main\java\seedu\address\model\config\Config.java

``` java
    public Config(ReadOnlyConfig config) {
        this();
        resetData(config);
    }

    public void resetData(ReadOnlyConfig config) {
        setLogLevel(config.getLogLevel());
        setTaskBookFilePath(config.getTaskBookFilePath());
    }

```
###### src\main\java\seedu\address\model\config\Config.java

``` java
    @Override
    public String getTaskBookFilePath() {
        return taskBookFilePath;
    }

    public void setTaskBookFilePath(String taskBookFilePath) {
        this.taskBookFilePath = taskBookFilePath;
    }

```
###### src\main\java\seedu\address\model\config\ReadOnlyConfig.java

``` java
/**
 * Unmodifiable view of a {@link Config} object.
 */
public interface ReadOnlyConfig {

    /**
     * Returns the configured log level.
     */
    Level getLogLevel();

    /**
     * Returns the configured task book file path.
     */
    String getTaskBookFilePath();

}
```
###### src\main\java\seedu\address\model\filter\NameContainsKeywordsPredicate.java

``` java
public class NameContainsKeywordsPredicate implements Predicate<Task> {
    private final Set<String> keywords;

    public NameContainsKeywordsPredicate(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public boolean test(Task task) {
        return keywords.stream()
                .filter(keyword -> StringUtil.containsIgnoreCase(task.getName().toString(), keyword))
                .findAny()
                .isPresent();
    }

}
```
###### src\main\java\seedu\address\model\Model.java

``` java
/**
 * The API of the Model component.
 */
public interface Model {

    //// Config

    /** Returns current config as a read-only view */
    ReadOnlyConfig getConfig();

    /** Returns configured task book file path. */
    String getTaskBookFilePath();

    /** Sets configured task book file path */
    void setTaskBookFilePath(String taskBookFilePath);

    //// Task Book

    /** Clears existing backing task book and replaces with the provided new task book data. */
    void resetTaskBook(ReadOnlyTaskBook newTaskBook);

    /** Returns the TaskBook */
    ReadOnlyTaskBook getTaskBook();

    //// Floating Tasks

```
###### src\main\java\seedu\address\model\Model.java

``` java
    void setFloatingTaskSortComparator(Comparator<? super FloatingTask> comparator);

    //// Deadline Tasks

```
###### src\main\java\seedu\address\model\Model.java

``` java
    void setDeadlineTaskSortComparator(Comparator<? super DeadlineTask> comparator);

    //// Event Tasks

    /** Adds the given event task */
    void addEventTask(EventTask eventTask);

    /** Retrieves the given event task from the specified index in the filtered event task list */
    EventTask getEventTask(int indexInFilteredList) throws IllegalValueException;

    /** Removes the given event task and returns it. */
    EventTask removeEventTask(int indexInFilteredList) throws IllegalValueException;

    /** Replaces the given event task with a new event task */
    void setEventTask(int indexInFilteredList, EventTask newEventTask) throws IllegalValueException;

    /** Returns the filtered event task list as an unmodifiable ObservableList */
    ObservableList<Optional<EventTask>> getFilteredEventTaskList();

    /**
     * Updates the filter of the filtered event task list to filter by the given predicate.
     *
     * If predicate is null, the filtered event task list will be populated with all event tasks.
     */
    void setEventTaskFilter(Predicate<? super EventTask> predicate);

    void setEventTaskSortComparator(Comparator<? super EventTask> comparator);

    ////undo redo
```
###### src\main\java\seedu\address\model\ModelManager.java

``` java
/**
 * Represents the in-memory model of the address book data.
 * All changes to any model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final Config config;
    private final TaskBook taskBook;

    private final ItemMappingList<FloatingTask> filteredFloatingTasks;
    private final ItemMappingList<DeadlineTask> filteredDeadlineTasks;
    private final ItemMappingList<EventTask> filteredEventTasks;

    //for undo
    private ArrayList<Commit> commits = new ArrayList<Commit>();
    private int head; //head points to a the current commit which holds the TaskBook displayed by the UI

    /**
     * Initializes a ModelManager with the given config and TaskBook
     * TaskBook and its variables should not be null
     */
    public ModelManager(ReadOnlyConfig config, ReadOnlyTaskBook taskBook) {
        super();
        assert taskBook != null;

        logger.fine("Initializing with config: " + config + " and task book: " + taskBook);

        this.config = new Config(config);
        this.taskBook = new TaskBook(taskBook);
        this.filteredFloatingTasks = new ItemMappingList<>(this.taskBook.getFloatingTasks());
        this.filteredDeadlineTasks = new ItemMappingList<>(this.taskBook.getDeadlineTasks());
        this.filteredEventTasks = new ItemMappingList<>(this.taskBook.getEventTasks());
        recordState(null);
    }

```
###### src\main\java\seedu\address\model\ModelManager.java

``` java
    @Override
    public ReadOnlyConfig getConfig() {
        return config;
    }

    @Override
    public String getTaskBookFilePath() {
        return config.getTaskBookFilePath();
    }

    @Override
    public void setTaskBookFilePath(String filePath) {
        config.setTaskBookFilePath(filePath);
    }

    //// Task Book

    @Override
    public void resetTaskBook(ReadOnlyTaskBook newData) {
        taskBook.resetData(newData);
        indicateTaskBookChanged();
    }

```
###### src\main\java\seedu\address\model\ModelManager.java

``` java
    @Override
    public void setFloatingTaskSortComparator(Comparator<? super FloatingTask> comparator) {
        filteredFloatingTasks.setSortComparator(comparator);
    }

    //// Deadline tasks

```
###### src\main\java\seedu\address\model\ModelManager.java

``` java
    @Override
    public synchronized DeadlineTask removeDeadlineTask(int indexInFilteredList) throws IllegalValueException {
        final int sourceIndex = filteredDeadlineTasks.getSourceIndex(indexInFilteredList);
        final DeadlineTask removedDeadline = taskBook.removeDeadlineTask(sourceIndex);
        filteredDeadlineTasks.remove(indexInFilteredList);
        indicateTaskBookChanged();
        return removedDeadline;
    }

    @Override
    public synchronized void setDeadlineTask(int indexInFilteredList, DeadlineTask newDeadlineTask)
            throws IllegalValueException {
        final int sourceIndex = filteredDeadlineTasks.getSourceIndex(indexInFilteredList);
        taskBook.setDeadlineTask(sourceIndex, newDeadlineTask);
        filteredDeadlineTasks.set(indexInFilteredList, newDeadlineTask);
        indicateTaskBookChanged();
    }

    @Override
    public ObservableList<Optional<DeadlineTask>> getFilteredDeadlineTaskList() {
        return filteredDeadlineTasks.getObservableListView();
    }

    @Override
    public void setDeadlineTaskFilter(Predicate<? super DeadlineTask> predicate) {
        filteredDeadlineTasks.setFilter(predicate);
    }

    @Override
    public void setDeadlineTaskSortComparator(Comparator<? super DeadlineTask> comparator) {
        filteredDeadlineTasks.setSortComparator(comparator);
    }

    //// Event tasks

    @Override
    public synchronized void addEventTask(EventTask eventTask) {
        taskBook.addEventTask(eventTask);
        filteredEventTasks.add(eventTask, taskBook.getEventTasks().size() - 1);
        indicateTaskBookChanged();
    }

```
###### src\main\java\seedu\address\model\ModelManager.java

``` java
    @Override
    public synchronized EventTask removeEventTask(int indexInFilteredList) throws IllegalValueException {
        final int sourceIndex = filteredEventTasks.getSourceIndex(indexInFilteredList);
        final EventTask removedEvent = taskBook.removeEventTask(sourceIndex);
        filteredEventTasks.remove(indexInFilteredList);
        indicateTaskBookChanged();
        return removedEvent;
    }

    @Override
    public synchronized void setEventTask(int indexInFilteredList, EventTask newEventTask)
            throws IllegalValueException {
        final int sourceIndex = filteredEventTasks.getSourceIndex(indexInFilteredList);
        taskBook.setEventTask(sourceIndex, newEventTask);
        filteredEventTasks.set(indexInFilteredList, newEventTask);
        indicateTaskBookChanged();
    }

```
###### src\main\java\seedu\address\model\ModelManager.java

``` java
    @Override
    public void setEventTaskSortComparator(Comparator<? super EventTask> comparator) {
        filteredEventTasks.setSortComparator(comparator);
    }

    private static class ItemMapping<E> {
        final Optional<E> value;
        Optional<Integer> sourceIndex;

        ItemMapping(Optional<E> value, Optional<Integer> sourceIndex) {
            this.value = value;
            this.sourceIndex = sourceIndex;
        }

        ItemMapping(E value, int sourceIndex) {
            this(Optional.of(value), Optional.of(sourceIndex));
        }

        static <E> ItemMapping<E> empty() {
            return new ItemMapping<E>(Optional.empty(), Optional.empty());
        }
    }

    private static class ItemMappingList<E> {
        private final ObservableList<E> sourceList;
        private final ObservableList<ItemMapping<E>> filteredList;
        private Predicate<? super E> filter;
        private Comparator<? super E> sortComparator;

        ItemMappingList(ObservableList<E> sourceList) {
            this.sourceList = sourceList;
            this.filteredList = FXCollections.observableArrayList();
            repopulate();
        }

        ObservableList<Optional<E>> getObservableListView() {
            return new MappedList<>(filteredList, itemMapping -> itemMapping.value);
        }

        void setFilter(Predicate<? super E> filter) {
            this.filter = filter;
            repopulate();
        }

        void setSortComparator(Comparator<? super E> comparator) {
            this.sortComparator = comparator;
            repopulate();
        }

        int getSourceIndex(int filteredIndex) throws IllegalValueException {
            try {
                return filteredList.get(filteredIndex).sourceIndex.get();
            } catch (IndexOutOfBoundsException | NoSuchElementException e) {
                throw new IllegalValueException("invalid index");
            }
        }

        E get(int filteredIndex) throws IllegalValueException {
            try {
                return filteredList.get(filteredIndex).value.get();
            } catch (IndexOutOfBoundsException | NoSuchElementException e) {
                throw new IllegalValueException("invalid index");
            }
        }

        void set(int filteredIndex, E item) throws IllegalValueException {
            final int sourceIndex = getSourceIndex(filteredIndex);
            try {
                filteredList.set(filteredIndex, new ItemMapping<>(item, sourceIndex));
            } catch (IndexOutOfBoundsException e) {
                throw new IllegalValueException("invalid index");
            }
        }

        void add(E item, int sourceIndex) {
            filteredList.add(new ItemMapping<>(item, sourceIndex));
        }

        void remove(int filteredIndex) throws IllegalValueException {
            int deletedSourceIndex = getSourceIndex(filteredIndex);
            filteredList.set(filteredIndex, ItemMapping.empty());
            // Adjust mapping of sourceIndexes
            for (ItemMapping<E> item : filteredList) {
                if (item.sourceIndex.isPresent() && item.sourceIndex.get() > deletedSourceIndex) {
                    item.sourceIndex = Optional.of(item.sourceIndex.get() - 1);
                }
            }
        }

        void repopulate() {
            ArrayList<ItemMapping<E>> newFilteredList = new ArrayList<>();
            for (int i = 0; i < sourceList.size(); i++) {
                final E item = sourceList.get(i);
                if (filter != null && !filter.test(item)) {
                    continue;
                }
                newFilteredList.add(new ItemMapping<E>(item, i));
            }
            if (sortComparator != null) {
                newFilteredList.sort((a, b) -> sortComparator.compare(a.value.get(), b.value.get()));
            }
            filteredList.setAll(newFilteredList);
        }
    }

    ////undo redo

```
###### src\main\java\seedu\address\model\task\EventTask.java

``` java
public final class EventTask extends Task {

    private static final String FMT_STRING = "EventTask[name=%s, duration=%s]";

    private final LocalDateTimeDuration duration;

    public EventTask(Name name, LocalDateTimeDuration duration) {
        super(name);
        assert duration != null;
        this.duration = duration;
    }

    public EventTask(String name, LocalDateTimeDuration duration) throws IllegalValueException {
        this(new Name(name), duration);
    }

    public EventTask(Name name, LocalDateTime start, LocalDateTime end) throws IllegalValueException {
        this(name, new LocalDateTimeDuration(start, end));
    }

    public EventTask(String name, LocalDateTime start, LocalDateTime end) throws IllegalValueException {
        this(name, new LocalDateTimeDuration(start, end));
    }

    public LocalDateTimeDuration getDuration() {
        return duration;
    }

    public LocalDateTime getStart() {
        return duration.getStart();
    }

    public LocalDateTime getEnd() {
        return duration.getEnd();
    }

    @Override
    public boolean equals(Object other) {
        return other == this
               || (other instanceof EventTask
               && name.equals(((EventTask)other).name)
               && duration.equals(((EventTask)other).duration));
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, duration);
    }

    @Override
    public String toString() {
        return String.format(FMT_STRING, name, duration);
    }

}
```
###### src\main\java\seedu\address\model\task\Task.java

``` java
    public Name getName() {
        return name;
    }

}
```
###### src\main\java\seedu\address\model\TaskBook.java

``` java
    /**
     * Tasks are copied into this TaskBook.
     */
    public TaskBook(ReadOnlyTaskBook toBeCopied) {
        this();
        resetData(toBeCopied);
    }

    /**
     * Replaces the contents of this TaskBook with {@code newData}.
     */
    public void resetData(ReadOnlyTaskBook newData) {
        setFloatingTasks(newData.getFloatingTasks());
        setDeadlineTasks(newData.getDeadlineTasks());
        setEventTasks(newData.getEventTasks());
    }

    //// floating task operations

```
###### src\main\java\seedu\address\model\TaskBook.java

``` java
    public void setEventTasks(Collection<EventTask> eventTasks) {
        this.eventTasks.setAll(eventTasks);
    }

    public void addEventTask(EventTask eventTask) {
        eventTasks.add(eventTask);
    }

```
###### src\main\java\seedu\address\model\TaskBook.java

``` java
    public void setEventTask(int index, EventTask newEventTask) {
        eventTasks.set(index, newEventTask);
    }

    //// util methods

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("floatingTasks", floatingTasks)
            .add("deadlineTasks", deadlineTasks)
            .add("eventTasks", eventTasks)
            .toString();
    }

```
###### src\main\java\seedu\address\model\TaskBookChangeListener.java

``` java
public class TaskBookChangeListener extends ObservableListChangeListener {

    public TaskBookChangeListener(ReadOnlyTaskBook taskBook) {
        super(taskBook.getFloatingTasks(), taskBook.getDeadlineTasks(), taskBook.getEventTasks());
    }

}
```
###### src\main\java\seedu\address\storage\config\ConfigStorage.java

``` java
/**
 * Represents a storage for {@link seedu.address.model.config.Config}
 */
public interface ConfigStorage {

    /**
     * Returns the file path of the config file.
     */
    String getConfigFilePath();

    /**
     * Returns the Config data as a {@link ReadOnlyConfig}.
     * Returns {@code Optional.empty()} if config file was not found.
     * @throws DataConversionException if the data in storage cannot be parsed.
     * @throws IOException if an IO error occurred while reading from the storage.
     */
    Optional<ReadOnlyConfig> readConfig() throws DataConversionException, IOException;

    /**
     * @see #readConfig()
     */
    Optional<ReadOnlyConfig> readConfig(String filePath) throws DataConversionException, IOException;

    /**
     * Saves the given {@link ReadOnlyConfig} to the storage.
     * @param config cannot be null.
     * @throws IOException if an IO error occurred while writing to the storage.
     */
    void saveConfig(ReadOnlyConfig config) throws IOException;

    /**
     * @see #saveConfig(ReadOnlyConfig)
     */
    void saveConfig(ReadOnlyConfig config, String filePath) throws IOException;

}
```
###### src\main\java\seedu\address\storage\config\JsonConfigModule.java

``` java
/**
 * Jackson module for serialization/deserialization of {@link Config} objects.
 */
public class JsonConfigModule extends Module {

    @Override
    public String getModuleName() {
        return "JsonConfigModule";
    }

    @Override
    public Version version() {
        return Version.unknownVersion();
    }

    @Override
    public void setupModule(SetupContext context) {
        final SimpleSerializers serializers = new SimpleSerializers();
        final SimpleDeserializers deserializers = new SimpleDeserializers();

        serializers.addSerializer(Level.class, new ToStringSerializer());
        deserializers.addDeserializer(Level.class, new JsonLevelDeserializer(Level.class));

        context.addSerializers(serializers);
        context.addDeserializers(deserializers);
        context.setMixInAnnotations(Config.class, JsonConfigMixin.class);
    }

}
```
###### src\main\java\seedu\address\storage\config\JsonConfigStorage.java

``` java
public class JsonConfigStorage implements ConfigStorage {

    private static final Logger logger = LogsCenter.getLogger(JsonConfigStorage.class);

    private final String filePath;

    private final ObjectMapper objectMapper;

    public JsonConfigStorage(String filePath, ObjectMapper objectMapper) {
        assert !CollectionUtil.isAnyNull(filePath, objectMapper);
        this.filePath = filePath;
        this.objectMapper = objectMapper;
    }

    public JsonConfigStorage(String filePath) {
        this(filePath, initDefaultObjectMapper());
    }

    private static ObjectMapper initDefaultObjectMapper() {
        return new ObjectMapper()
                .enable(SerializationFeature.INDENT_OUTPUT)
                .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
                .registerModule(new Jdk8Module())
                .registerModule(new JsonConfigModule());
    }

    @Override
    public String getConfigFilePath() {
        return filePath;
    }

    @Override
    public Optional<ReadOnlyConfig> readConfig() throws DataConversionException, IOException {
        return readConfig(filePath);
    }

    @Override
    public Optional<ReadOnlyConfig> readConfig(String filePath) throws DataConversionException, IOException {
        assert filePath != null;
        final File configFile = new File(filePath);
        if (!configFile.exists()) {
            logger.info("Config file " + configFile + " not found");
            return Optional.empty();
        }
        try {
            return Optional.of(objectMapper.readValue(configFile, Config.class));
        } catch (JsonProcessingException e) {
            throw new DataConversionException(e);
        }
    }

    @Override
    public void saveConfig(ReadOnlyConfig config) throws IOException {
        saveConfig(config, filePath);
    }

    @Override
    public void saveConfig(ReadOnlyConfig config, String filePath) throws IOException {
        assert !CollectionUtil.isAnyNull(config, filePath);
        final File file = new File(filePath);
        FileUtil.createIfMissing(file);
        objectMapper.writeValue(file, config);
    }

}
```
###### src\main\java\seedu\address\storage\config\JsonLevelDeserializer.java

``` java
public class JsonLevelDeserializer extends FromStringDeserializer<Level> {

    public JsonLevelDeserializer(Class<?> vc) {
        super(vc);
    }

    @Override
    protected Level _deserialize(String value, DeserializationContext ctxt) throws IOException {
        return Level.parse(value);
    }

}
```
###### src\main\java\seedu\address\storage\JsonEventTaskMixin.java

``` java
@JsonPropertyOrder({"name", "start", "end"})
public abstract class JsonEventTaskMixin {

    JsonEventTaskMixin(@JsonProperty("name") Name name, @JsonProperty("start") LocalDateTime start,
                       @JsonProperty("end") LocalDateTime end) {
    }

    @JsonIgnore
    abstract LocalDateTimeDuration getDuration();

}
```
###### src\main\java\seedu\address\storage\JsonLocalDateTimeDurationMixin.java

``` java
@JsonPropertyOrder({"start", "end"})
public abstract class JsonLocalDateTimeDurationMixin {

    public JsonLocalDateTimeDurationMixin(@JsonProperty("start") LocalDateTime start,
                                          @JsonProperty("end") LocalDateTime end) {
    }

    @JsonIgnore
    abstract List<TemporalUnit> getUnits();

}
```
###### src\main\java\seedu\address\storage\JsonNameMixin.java

``` java
public abstract class JsonNameMixin {
    @JsonCreator
    JsonNameMixin(String name) {}

    @JsonValue
    public abstract String toString();
}
```
###### src\main\java\seedu\address\storage\JsonStorageModule.java

``` java
public class JsonStorageModule extends Module {

    @Override
    public String getModuleName() {
        return "JsonStorageModule";
    }

    @Override
    public Version version() {
        return Version.unknownVersion();
    }

    @Override
    public void setupModule(SetupContext context) {
        context.setMixInAnnotations(LocalDateTimeDuration.class, JsonLocalDateTimeDurationMixin.class);
        context.setMixInAnnotations(Name.class, JsonNameMixin.class);
        context.setMixInAnnotations(Priority.class, JsonPriorityMixin.class);
        context.setMixInAnnotations(Task.class, JsonTaskMixin.class);
        context.setMixInAnnotations(FloatingTask.class, JsonFloatingTaskMixin.class);
        context.setMixInAnnotations(EventTask.class, JsonEventTaskMixin.class);
        context.setMixInAnnotations(DeadlineTask.class, JsonDeadlineTaskMixin.class);
        context.setMixInAnnotations(TaskBook.class, JsonTaskBookMixin.class);
    }

}
```
###### src\main\java\seedu\address\storage\JsonTaskBookStorage.java

``` java
public class JsonTaskBookStorage implements TaskBookStorage {

    private static final Logger logger = LogsCenter.getLogger(JsonTaskBookStorage.class);

    private String filePath;

    private final ObjectMapper objectMapper;

    public JsonTaskBookStorage(String filePath, ObjectMapper objectMapper) {
        assert !CollectionUtil.isAnyNull(filePath, objectMapper);
        this.filePath = filePath;
        this.objectMapper = objectMapper;
    }

    public JsonTaskBookStorage(String filePath) {
        this(filePath, initDefaultObjectMapper());
    }

    private static ObjectMapper initDefaultObjectMapper() {
        return new ObjectMapper()
            .enable(SerializationFeature.INDENT_OUTPUT)
            .registerModule(new JavaTimeModule())
            .registerModule(new JsonStorageModule());
    }

    @Override
    public String getTaskBookFilePath() {
        return filePath;
    }

    @Override
    public Optional<ReadOnlyTaskBook> readTaskBook() throws DataConversionException, IOException {
        return readTaskBook(filePath);
    }

    @Override
    public Optional<ReadOnlyTaskBook> readTaskBook(String filePath) throws DataConversionException, IOException {
        assert filePath != null;
        final File taskBookFile = new File(filePath);
        if (!taskBookFile.exists()) {
            logger.info("TaskBook file " + taskBookFile + " not found");
            return Optional.empty();
        }
        try {
            return Optional.of(objectMapper.readValue(taskBookFile, TaskBook.class));
        } catch (JsonProcessingException e) {
            throw new DataConversionException(e);
        }
    }

    @Override
    public void saveTaskBook(ReadOnlyTaskBook taskBook) throws IOException {
        saveTaskBook(taskBook, filePath);
    }

    @Override
    public void saveTaskBook(ReadOnlyTaskBook taskBook, String filePath) throws IOException {
        assert !CollectionUtil.isAnyNull(taskBook, filePath);
        final File file = new File(filePath);
        FileUtil.createIfMissing(file);
        objectMapper.writeValue(file, taskBook);
    }

    @Override
    public void moveTaskBook(String newFilePath) throws IOException {
        assert newFilePath != null;
        final File file = new File(filePath);
        final File newFile = new File(newFilePath);
        if (FileUtil.isFileExists(newFile)) {
            throw new IOException(newFilePath + " already exists.");
        }
        Files.createParentDirs(newFile);
        Files.move(file, newFile);
        filePath = newFilePath;
    }

}
```
###### src\main\java\seedu\address\storage\JsonTaskMixin.java

``` java
public abstract class JsonTaskMixin {
    JsonTaskMixin(@JsonProperty("name") Name name) {}
}
```
###### src\main\java\seedu\address\storage\StorageManager.java

``` java
/**
 * Manages storage of TaskBook data in local storage.
 */
public class StorageManager extends ComponentManager implements Storage {

    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);

    private final ConfigStorage configStorage;

    private final TaskBookStorage taskBookStorage;

    public StorageManager(ConfigStorage configStorage, TaskBookStorage taskBookStorage) {
        super();
        this.configStorage = configStorage;
        this.taskBookStorage = taskBookStorage;
    }

    public StorageManager(ConfigStorage configStorage, String taskBookFilePath) {
        this(configStorage, new JsonTaskBookStorage(taskBookFilePath));
    }

    public StorageManager(String configFilePath, String taskBookFilePath) {
        this(new JsonConfigStorage(configFilePath), taskBookFilePath);
    }

    // ================ ConfigStorage methods =========================

    @Override
    public String getConfigFilePath() {
        return configStorage.getConfigFilePath();
    }

    @Override
    public Optional<ReadOnlyConfig> readConfig() throws DataConversionException, IOException {
        return configStorage.readConfig();
    }

    @Override
    public Optional<ReadOnlyConfig> readConfig(String filePath) throws DataConversionException, IOException {
        return configStorage.readConfig(filePath);
    }

    @Override
    public void saveConfig(ReadOnlyConfig config) throws IOException {
        configStorage.saveConfig(config);
    }

    @Override
    public void saveConfig(ReadOnlyConfig config, String filePath) throws IOException {
        configStorage.saveConfig(config, filePath);
    }

    // ================ TaskBook methods ==============================

```
###### src\main\java\seedu\address\storage\StorageManager.java

``` java
    @Override
    public void moveTaskBook(String newFilePath) throws IOException {
        logger.fine("Attempting to move task book from " + taskBookStorage.getTaskBookFilePath() + " to "
                    + newFilePath);
        taskBookStorage.moveTaskBook(newFilePath);
    }

}
```
###### src\main\java\seedu\address\storage\TaskBookStorage.java

``` java
    /**
     * Moves the task book to the newFilePath.
     * @throws IOException if an IO error occurred while moving the task book file.
     *         The configured task book file path will remain unchanged.
     */
    void moveTaskBook(String newFilePath) throws IOException;

}
```
###### src\main\java\seedu\address\ui\DeadlineTaskListCard.java

``` java
public class DeadlineTaskListCard extends UiPart<Pane> {

    private static final String FXML = "/view/DeadlineTaskListCard.fxml";

    @FXML
    private Label indexLabel;

    @FXML
    private Label nameLabel;

    @FXML
    private Label dueLabel;

    @FXML
    private Label finishedLabel;

    /**
     * @param deadlineTask The deadline task to display. Can be null to not display anything.
     */
    public DeadlineTaskListCard(DeadlineTask deadlineTask, int index) {
        super(FXML);
        if (deadlineTask != null) {
            indexLabel.setText(IndexPrefix.DEADLINE.getPrefixString() + index + ". ");
            nameLabel.setText(deadlineTask.getName().toString());
            dueLabel.setText(deadlineTask.getDue().toString());
            finishedLabel.setText(String.valueOf(deadlineTask.isFinished()));
            if (deadlineTask.isFinished()) {
                getRoot().getStyleClass().add("finished");
            } else if (deadlineTask.getDue().isBefore(LocalDateTime.now())) {
                getRoot().getStyleClass().add("overdue");
            }
        } else {
            getRoot().setVisible(false);
        }
    }

}
```
###### src\main\java\seedu\address\ui\DeadlineTaskListPane.java

``` java
public class DeadlineTaskListPane extends UiPart<Pane> {

    private static final String FXML = "/view/DeadlineTaskListPane.fxml";

    @FXML
    private ListView<Optional<DeadlineTask>> deadlineTaskListView;

    public DeadlineTaskListPane(ObservableList<Optional<DeadlineTask>> deadlineTaskList) {
        super(FXML);
        deadlineTaskListView.setItems(deadlineTaskList);
        deadlineTaskListView.setCellFactory(listView -> new DeadlineTaskListCell());
    }

    private static class DeadlineTaskListCell extends ListCell<Optional<DeadlineTask>> {
        @Override
        protected void updateItem(Optional<DeadlineTask> deadlineTask, boolean empty) {
            super.updateItem(deadlineTask, empty);
            final DeadlineTaskListCard card = new DeadlineTaskListCard(empty ? null : deadlineTask.orElse(null), getIndex() + 1);
            setGraphic(card.getRoot());
        }
    }

}
```
###### src\main\java\seedu\address\ui\EventTaskListCard.java

``` java
public class EventTaskListCard extends UiPart<Pane> {

    private static final String FXML = "/view/EventTaskListCard.fxml";

    @FXML
    private Label indexLabel;

    @FXML
    private Label nameLabel;

    @FXML
    private Label startLabel;

    @FXML
    private Label endLabel;

    /**
     * @param eventTask The event task to display. Can be null to not display anything.
     */
    public EventTaskListCard(EventTask eventTask, int index) {
        super(FXML);
        if (eventTask != null) {
            indexLabel.setText(IndexPrefix.EVENT.getPrefixString() + index + ". ");
            nameLabel.setText(eventTask.getName().toString());
            startLabel.setText(eventTask.getStart().toString());
            endLabel.setText(eventTask.getEnd().toString());
            if (eventTask.getEnd().isBefore(LocalDateTime.now())) {
                getRoot().getStyleClass().add("finished");
            } else if (eventTask.getStart().isBefore(LocalDateTime.now())) {
                getRoot().getStyleClass().add("inProgress");
            }
        } else {
            getRoot().setVisible(false);
        }
    }

}
```
###### src\main\java\seedu\address\ui\EventTaskListPane.java

``` java
public class EventTaskListPane extends UiPart<Pane> {

    private static final String FXML = "/view/EventTaskListPane.fxml";

    @FXML
    private ListView<Optional<EventTask>> eventTaskListView;

    public EventTaskListPane(ObservableList<Optional<EventTask>> eventTaskList) {
        super(FXML);
        eventTaskListView.setItems(eventTaskList);
        eventTaskListView.setCellFactory(listView -> new EventTaskListCell());
    }

    private static class EventTaskListCell extends ListCell<Optional<EventTask>> {
        @Override
        protected void updateItem(Optional<EventTask> eventTask, boolean empty) {
            super.updateItem(eventTask, empty);
            final EventTaskListCard card = new EventTaskListCard(empty ? null : eventTask.orElse(null), getIndex() + 1);
            setGraphic(card.getRoot());
        }
    }

}
```
###### src\main\java\seedu\address\ui\HelpWindow.java

``` java
/**
 * Controller for a help page
 */
public class HelpWindow extends UiPart<Stage> {

    private static final String ICON = "/images/help_icon.png";
    private static final String FXML = "/view/HelpWindow.fxml";
    private static final String TITLE = "Help";
    private static final String USERGUIDE_URL =
            "https://github.com/se-edu/addressbook-level4/blob/master/docs/UserGuide.md";

    @FXML
    private WebView webView;

    public HelpWindow() {
        super(FXML);
        getRoot().initModality(Modality.WINDOW_MODAL);
        FxViewUtil.setStageIcon(getRoot(), ICON);
        webView.getEngine().load(USERGUIDE_URL);
    }

}
```
###### src\main\java\seedu\address\ui\MainWindow.java

``` java
    void fillInnerParts(Config config, Logic logic) {
        floatingTaskListPane = new FloatingTaskListPane(logic.getFilteredFloatingTaskList());
        floatingTaskListRegion.setNode(floatingTaskListPane.getRoot());
        eventTaskListPane = new EventTaskListPane(logic.getFilteredEventTaskList());
        eventTaskListRegion.setNode(eventTaskListPane.getRoot());
        deadlineTaskListPane = new DeadlineTaskListPane(logic.getFilteredDeadlineTaskList());
        deadlineTaskListRegion.setNode(deadlineTaskListPane.getRoot());
        resultDisplay = new ResultDisplay();
        resultDisplayPlaceholder.setNode(resultDisplay.getRoot());
        commandBox = new CommandBox(resultDisplay, logic);
        commandBoxPlaceholder.setNode(commandBox.getRoot());
        statusBarFooter = new StatusBarFooter(config.getTaskBookFilePath());
        statusbarPlaceholder.setNode(statusBarFooter.getRoot());
    }

```
###### src\main\java\seedu\address\ui\ResultDisplay.java

``` java
/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultDisplay extends UiPart<Pane> {

    private static final String FXML = "/view/ResultDisplay.fxml";

    @FXML
    private TextArea resultDisplay;

    private final StringProperty displayed = new SimpleStringProperty("");

    public ResultDisplay() {
        super(FXML);
        resultDisplay.textProperty().bind(displayed);
    }

```
###### src\main\java\seedu\address\ui\UiPart.java

``` java
/**
 * Base class for UI parts.
 * A 'UI part' represents a distinct part of the UI. e.g. Windows, dialogs, panels, status bars, etc.
 */
public class UiPart<T> {

    private final FXMLLoader loader;

    public UiPart(URL url) {
        assert url != null;
        loader = new FXMLLoader(url);
        loader.setController(this);
        try {
            loader.load();
        } catch (IOException e) {
            throw new RuntimeException("Unexpected exception occurred while loading " + url + ": " + e);
        }
        EventsCenter.getInstance().registerHandler(this);
    }

    public UiPart(String name) {
        this(MainApp.class.getResource(name));
    }

    public T getRoot() {
        return loader.getRoot();
    }
}
```
###### src\main\java\seedu\address\ui\UiRegion.java

``` java
public class UiRegion extends Region {

    public UiRegion() {
        super();
        setMinHeight(Region.USE_PREF_SIZE);
    }

    public Node getNode() {
        return getChildren().size() > 0 ? getChildren().get(0) : null;
    }

    public void setNode(Node child) {
        getChildren().clear();
        getChildren().add(child);
    }

    @Override
    protected void layoutChildren() {
        for (Node node : getChildren()) {
            layoutInArea(node, 0, 0, getWidth(), getHeight(), 0, HPos.LEFT, VPos.TOP);
        }
    }

}
```
